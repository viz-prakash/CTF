# Pico-CTF 2014: Problem-Name

**Category:** Binary Exploitation
**Points:** 100
**Total Solves:** Not Available
## Problem Description:
[//]: # (Description of your problem. For eg use below description as a template)
[//]: # (> This program is vulnerable to a format string attack! See if you can modify a variable by supplying a format string! The binary can be found at /home/format/ on the shell server. The source can be found [here](format.c\).)

## Write-up
[//]: # (> Your write up goes here.)
Challange gave a binary which was reading from stdin and storing the read content in two char array varaible, and it's susceptible to attack because it was using strlen and strncpy, both of which expectes a \\0 string terminator. Problem was it stored
both the variables continuously on stack. It read both of them with safe function ctf\_readsn,
which uses system call read to read, but problem here is read dosn't appends \\x0 at the end unless 
it read \r. So, if we provide input of 256 characters strlen will not find \\0 and will add the 
length of second variable to the first one, as both are stored continuously on stack.

Let's look closely what program did, first it read from stdin maxximum 256 bytes, and stored it
on stack, then printed it. Again ask for user input from stdin maxximum 256 bytes. Then it goes on
to copy the first string on stack. As vulnerability describe above while copying the first string
it will copy both the strings if we provide first input larger than 256 bytes. Then it does few
stuff at the last byte of copied of this copied string. Then it goes on to copy the second string
on stack. After copying the second string it expect 0x12345678 at specific address on stack, which
is falls in the range wehre these two read variables are getting copied. So, attack is simple to
write 0x12345678 on the required address by using the bug described above.

Solution to the challange is in [script](solve.py).
## Other write-ups and resources

* None
